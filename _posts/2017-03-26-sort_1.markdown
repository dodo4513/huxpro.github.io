---
layout:     post
title:      "선택 정렬, 삽입 정렬, 버블정렬, 쉘 정렬 정리 및 구현 예제"
subtitle:   "각 정렬을 살펴보고 구현해보자!"
date:       2017-3-26
author:     "Xavy"
catalog:    true
tags:
    - Interview
    - Algorithm
---

### 시작하기 전에

전산학에서 **정렬 이라는 주제는 전통적으로 중요한 주제** 다. 그 결과 오늘날까지 다양한 방법들의 정렬이 고안되었고 사용되었다. 그 중 선택, 삽입, 버블, 쉘 정렬에 대해서 간단하게 알아보려고 한다. 해당 정렬들은 수행속도가 다소 오래 걸린다고 평가받는 정렬들인데(아, 쉘 정렬은 빠른 편에 속하는 것 같다), 구현이 간단하므로 제한적인 상황에 한해 사용할 수 있다. 여기서 제한적인 상황이라는 표현은 각 정렬에서 다시 살펴보도록 하자.

이 외에 아주 조금 복잡하지만, 성능이 월등히 좋은 정렬들도 있다. (물론, n이 충분히 클 때 기준으로) 해당 정렬들은 아래의 포스트에서 알아보도록 하자.

[합병 정렬, 퀵 정렬, 힙 정렬, 기수 정렬 정리 및 구현 예제](#)

아래의 정렬을 보다 보면 SWAP(x, y) 매크로가 보일 텐데, 정렬 예제이므로 로직에 더 집중할 수 있도록 매크로로 처리했다. `#define SWAP( x, y ) { x=x^y; y=x^y; x=x^y; }`를 소스 상단에 붙여넣으면 된다.

### 선택 정렬(Select sort)

###### 구현

```c++
void SelectSort(){
	for(int i=0; i<10; i++){
		int minValue = target[i];
		int minIndex = i;
		for(int j=i+1; j<10; j++){
			if(minValue > target[j]){
				minValue = target[j];
				minIndex = j;
			}
		}
		SWAP(target[i], target[minIndex]);
	}
}
```

- 가장 작은 수를 찾아 가장 앞에 두고, 남은 수 중 가장 작은 수를 찾아 그다음에 두는 방식으로 반복하는 정렬.

###### 성능

|구분|최선 성능|최악 성능|평균 성능|
|---
|선택정렬|n^2|n^2|n^2|

- 최악이나 최선이나 비교의 크기는 같고 교환 횟수만 차이가 나기 때문에 n이 정렬이 돼있든 안돼있든 항상 n^2의 속도로 동작한다.

###### 총평

- 비교 횟수는 (n^2)/2 정도로 많지만, 교환 횟수는 많아야 n번이다. 따라서 **value의 크기가 크고 key값이 작을 때 굉장히 유용하다.** 물론 n의 크기가 매우 크지는 않을 때 말이다.

- 멀리 떨어진 배열 요소와 교환을 하므로 **안정성은 없다.** 이때 '안정성을 가진다'란 같은 값을 가진 데이터들을 정렬할 때, 기존의 순서가 바뀌지 않음을 보장한다는 말이다.

### 버블 정렬

###### 구현

```c++
void BubbleSort() {
	for (int i=0; i<10; i++){
		for(int j=0; j<10-i-1; j++){
			if(target[j+1] < target[j]){
				SWAP(target[j+1], target[j]);
			}
		}
	}
}
```

- 거품이 떠오르는 모양으로 정렬한다. 로직이 굉장히 단순한 정렬.

###### 성능

|구분|최선 성능|최악 성능|평균 성능|
|---
|선택정렬|n^2|n^2|n^2|

- 앞서본 선택 정렬과 동일하다. 비교의 횟수는 언제나 같고 교환 횟수만 차이나므로 항상 n^2의 속도로 동작한다.

###### 총평

- 아주 손쉽게 구현할 수 있지만, 성능이 그만큼 우울한 정렬이다. 선택 정렬과 유사한 특정을 가진다. 그러나 바로 옆의 값과 비교 및 교환하기 때문에, 선택 정렬과는 다르게 **비교하는 if문의 조건에 '='을 넣지 않는다면 안정성을 가진다.**

### 삽입 정렬

###### 구현

```c++
void InsertionSort(){
	for(int i=1; i<10; i++){
		int temp = target[i];
		for (int j=i; target[j-1] > temp && j>0; j--){
			target[j] = target[j-1];
		}
		target[j] = temp;
	}
}
```

- 삽입 정렬은 이미 정렬이 된 부분에 새로운 키를 적절한 장소에 삽입하는 동작을 반복하는 정렬.

###### 성능

|구분|최선 성능|최악 성능|평균 성능|
|---
|선택정렬|n^2|**n**|n^2|

- 정렬이 되어 있는 상태라면 교환은 한 번도 하지 않고 비교만 n번을 하므로 매우 빠르다. 그러나 반대로 정렬돼 있는 상태라면 이동과 비교 횟수는 n*(n-1)/2가 되어 느리다.

###### 총평

- 보통 n^2의 정렬 알고리즘 중 **평균적인 성능이 가장 좋은 것** 으로 알려져 있다.

- **입력 데이터의 정렬 여부에 굉장히 민감** 하다. 현실에 존재하는 자료구조는 정렬 안 된 데이터도 많지만, 어느 정도 정렬된 자료도 데이터도 심심찮게 존재하기 때문에(한두번 가공된 정보들) 해당 특성은 꽤 의미가 있다.

- 역시나 바로 옆의 데이터와 비교하기 떄문에 **안정 정렬** 이다.
안정 정렬.

### 쉘 정렬

###### 성능

|구분|최선 성능|최악 성능|평균 성능|
|---
|선택정렬|n^1.5|n|n^1.5|

###### 삽입 정렬의 한계와 쉘 정렬

 삽입 정렬은 이미 정렬된 배열이나 대충 정렬된 배열에 대해 매우 뛰어난 성능을 보이지만 그렇지 않은 경우 매우 느리다. 이는 삽입 정렬이 바로 인접한 요소와 비교를 하기 때문이다. 그래서 만약 역순 배열의 경우 제일 작은 키값이 가장 뒤에 있으므로 매번 배열의 끝까지 비교와 이동을 한다.
 
 **쉘 정렬은 위와 같은 문제를 해결하기 위해 h만큼의 간격으로 떨어진 레코드를 삽입하는 정렬** 이다. H가 10이라면 0, 10, 20, 30 ..의 요소만 뽑아서 우선 삽입 정렬을 한다. 그리고 h를 적당히 줄이는데 2를 나누어 h를 5라고 하면 1, 6, 11 .. 요소를 뽑아 정렬 하는 방식으로 반복한다. 결국 h는 1이 될 때 마지막 정렬을 하게되는데 이미 배열은 거의 다 정렬된 상태이므로 매우 빠른 속도로 삽입 정렬할 수 있다.

 과거에 **h = n/3 +1이 최적이라는 연구결과** 가 있다고 들은 것 같은데 출처는 잘 기억이 안 난다..

 마지막으로 쉘 정렬은 띠엄띠엄 비교하기 때문에 불안정 정렬이다.
